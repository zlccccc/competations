一道没意思的分块题

$q \le 1e5​$ 个操作：

插入或者删除一个数字 $x \le 1e6$；删除保证 $x$ 出现过

查询一个数字 $y \le 1e6$ 与现在存在的 $x$ 中的所有因子的差的 $abs$ 之和 $(如果感觉简单就改成平方和)​$ 是多少

复杂度 $q\sqrt{\max(x,y)}$

做法：维护数字个数和数字之和是几，分块即可；想卡常卡掉 $q\sqrt{x因子个数}*一个\ BIT\ 的\ log​$ 的方法



一道还有点意思的分块题，看了看带个log还是不行啊QAQ

维护一个序列 $f(x)​$；

$q \le 4e4 $ 个操作：

给定 $x \le 4e4\  ; y \le 1e9$；令 $x$ 的所有因子位置加 $y$

每次操作后进行一次前缀和操作

查询此时的 $f(y)​$

复杂度 $\max(x) \sqrt{q} + q * 最多因子个数​$

做法：直接对查询分块，暴力维护序列，$(t1,x1)$ 对 $(t2,x2)$ 贡献为 $C(t2-t1-1+x2-x1, x2-x1)$

查询分两段贡献，第一段就直接 $for​$ 一遍序列查询，第二段考虑同一块前面插入的对答案的贡献

考虑分块大小 $B = \sqrt{q\ log\max{(x)}}​$ 复杂度为：

$查询 = {B^2*因子个数 + B * \max(x) } ​$

$插入 =  \frac{q}{B} * \max(x) * log(x)\ +\ q\ * 因子个数 $

每次不需要更新新的数组，更新最初的数组

也就是 $time=t$ 更新最初的数组，某个位置相当于乘 $(1-x)^t$ ，也就是个负的....还是得 $fft$ 带个log




## 题目描述

小 $Z​$ 是一个非常努力的人 (这句是假的) ，他每天都在刷题 (这句更是假的)。小 $Z​$ 刷题有个特点，他经常去刷专题 (这句也是假的) ，专题中题目数量可能非常多，而且每个专题中题目的难度相当。某一天，小 $T​$ 告诉他，你刷的水题太多了，刷题应该按照基本法，一个更比一个 ♂ 难。这样的话，你每刷够 $x​$ 道题，你就能获得大小为 $x^k​$ 的提升。

假设小 $T​$ 说的是真的，假设对于小 $Z​$ 已经刷过的题目所有的上升子序列，长度为 $x​$ 就能获得大小为 $x^k​$ 的提升，那么他现在已经获得了多少的提升了呢？答案对 $10^9+7​$ 取模

也就是说，现给定一个非常长的序列，求其中所有上升子序列的长度 $k$ 次方之和，答案对 $10^9+7$ 取模

序列非常长，输入以 "数字大小 数字个数"​ 这样的形式给出 

注意，长度为 $1$ 的序列也要计入答案

## 输入

第一个数为数据组数 $T​$ 

对于每组数据

每行开头两个数字 $n\ k​$ 表示不同数字段数和次方大小 $n \le 100,000; \ k \le 20​$

接下来 $n$ 行，每行两个数字 $x$ 和 $y$，代表数字大小和数字个数 $x \le 1,000,000;\ y \le 1,000,000,000$

数据保证 $\sum n \le 100,000$

## 输出

对于每组数据，输出一行，不下降子序列的长度 $k​$ 次方之和

## 输入样例

    1
    3 2
    4 1
    3 2
    5 1

## 输出样例

    16

## 样例解释

对于第一组数据，序列的样子是 `4 3 3 5` ，其中长度为 `1` 的上升子序列共 `4​` 个，长度为 `2` 的上升子序列共 `3` 个，所以输出 `4*1 + 3*4 = 16` 。

---

### Problem Setter: zlc1114
### Problem Tester:

## 校赛出题附加信息

题目时间复杂度 $O(nklogn+nk^2)$ 空间复杂度 $O(n)​$